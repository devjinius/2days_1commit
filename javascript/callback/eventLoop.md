# 자바스크립트의 이벤트루프와 콜백함수

## 이벤트루프와 싱글 쓰레드

자바스크립트와 콜백은 뗄레야 뗄 수 없는 관계라고 생각한다. 흔히들 자바스크립트는 싱글쓰레드 기반이라고 얘기합니다. 그게 바로 이벤트루프가 싱글 쓰레드기 때문에 하는 얘기입니다. 그럼 이 이벤트 루프는 무엇일까요?

## 자료구조

스택과 큐의 구조는 이미 알고 있을 것입니다. 스택은 LIFO이며 큐는 FIFO입니다. 스택은 밑이 비어있는 컵 모양에 넣고 빼는 것이며 큐는 양쪽이 뚫려있는 튜브라고 말합니다. 

이 자료구조는 자바스크립트 엔진에서 사용됩니다. 바로 호출 '스택'과 태스크 '큐'입니다.

호출 스택은 어느 언어에서도 존재합니다. 쉽게 생각하자면 [main(), a(), b()] 구조로 호출되면 b -> a -> main 순으로 빠져 나가게 됩니다. 자 그러면 이제 `setTimeout()`을 생각해봅시다.

```javascript
function foo() {
	console.log("b");
}
console.log("a");
setTimeout(foo, 0);
console.log("c");
```

이러면 출력결과는 당연히 a -> c -> b가 됩니다. 의사코드로 소스를 분석해봅시다.

1. a를 출력해라
2. 0초 뒤에 foo를 실행해라
3. c를 출력해라

그렇다면 a -> b -> c가 되어야 하는것 아닐까요?? 이는 호출스택에서는 당연히 맞지만 자바스크립트에서는 그렇지 않습니다. 자바스크립트는 호출 스택만 사용하지 않기 때문이죠. 자바스크립트는 호출스택, 백그라운드, 태스크 큐(es6+부터는 큐 관리방식이 변화되어 태스크 큐 이외도 존재)라는 개념이 존재합니다.

![](C:\2days-1commit\javascript\callback\eventLoop.png)

뭐 이런 구조입니다. 자 이제 코드대로 생각을 해봅시다. 

1. main() 스택에 들어감
2. log("a") 도 스택에 들어간 뒤 실행
3. setTimeout()이 스택에 들어간 뒤 실행 - 백그라운드에서 0초뒤에 foo를 "실행"시키라고 명령
4. 0초가 지나 "태스크큐"에 foo()들어감
5. log("c") 가 스택에 들어간 뒤 실행
6. main() 종료
7. 태스크 큐에 있던 foo()를 호출스택에 밀어넣음 (이벤트 루프가 전역 컨텍스트의 main이 종료되면 큐 실행)
8. foo()가 호출스택에 들어간 뒤 실행

이런 구조입니다. 그래서 결과가 그렇게 나왔던것입니다.

## 콜백함수

이런 자바스크립트의 싱글 쓰레드 구조에서 비동기성의 이벤트 기반 실행이나 ajax요청이 필요하다면 콜백 함수를 이용해 백그라운드로 보내 이를 큐를 통해 호출 스택으로 보내 해결하게 됩니다. 

자바스크립트에서는 쓰레드를 통해 병렬처리가 안되기 때문에 콜백함수의 사용은 뗄 수가 없게 되는 것입니다.

## 큐와 콜백

이러한 이벤트 루프의 가장 중요한 점은 바로 위 과정의 3번과 4번 그리고 7번입니다. 흔히 setTimeout(foo, 3)이라는 함수를 말할 때 foo 함수를 3초 뒤에 실행시켜라 라고 생각합니다. 그러나 4번에 보듯 foo는 일정시간 뒤에 실행되는게 아니라 큐에 들어가게 됩니다. 

3번에 `백그라운드에서 0초뒤에 foo를 "실행"시키라고 명령`이라고는 적었지만 정확히 말하자면 `foo를 "큐"에 집어넣어라` 가 맞는 것입니다. 큐에 아무것도 없다면 3초뒤에 바로 실행이 되겠지만 만일 다른 콜백으로 인해 다른 작업들이 존재한다면 어떻게 될까요??

맞습니다. 3초가 넘어가서 실행되게 됩니다. setTimeout()이라는 함수는 n초 뒤에 콜백을 단순히 큐에 집어넣는게 끝입니다. 이 큐에 들어간 콜백은 이벤트 루프가 스택으로 밀어넣어 실행됩니다. 코드를 간단히 보자면 아래와 같습니다.

```javascript
var eventLoop = [];
var event;

while(true) {
    // 틱!
    if (eventLoop.length > 0) {
        event = eventLoop.shift();
    }
    
    try {
        event(); // 호출스택으로 밀어넣는다
    }
    catch(err) {
        //...
    }
}
```

이 큐에 이미 대기번호가 100개가 있다면 foo는 101번째 대기표를 받게 될 것입니다. 따라서 setTimeout()은 지정한 시간동안은 실행되지 않는 것은 보장할 수 있지만 지정한 시간에 실행되는것은 보장할 수 없습니다.

## 현재 이벤트 루프

es6+부터는 잡큐와 같은 새로운 개념이 등장하고 promise를 이용해 콜백을 처리하게 되는데 이는 나중에 더 다루도록 하겠습니다.